use Assert, Collection, ContentType, Date, Decode, Document, Encode, Excel, ExifTool, File, Hash, MariaDB, Math, Mongo, MSSQL, MySQL, Oracle, Properties, SQLite, Stream, String, System, Template, Web, XML, XURL, Postgres;


//-------------------------------------------------------------------------
//						  SETUP
//-------------------------------------------------------------------------

var targetDBName = "contentStore";
var targetDB = Mongo.connect(targetDBName);
var sourceDB  = Mongo.connect("udm_provincie_utrecht_PROD");


//-------------------------------------------------------------------------
//						  MAIN
//-------------------------------------------------------------------------


transformAllVersions();

function transformAllVersions() {
    foreach(i, doc in allDocsVersions()) {
    var versions = doc.original.versions; 
    foreach(v in versions){
        var transformedDoc = {};
        var model = {};
        transformedDoc += {"kind": "RECORD"};
        // Create rtecord, createe binary, create acls
         model +=mapVersionsRequiredProperties(v) ; 
         model += mapDocument(doc) ;
         var label = v.r_version_label[0];
         model.versionInfo.label = label;
         var isCurrent = Collection.contains(v.r_version_label, "CURRENT") ;
          model.versionInfo.isCurrent = isCurrent;
         var modify = v.r_modify_date;
         model.lastModified.date = modify;
         
     0;
      transformedDoc += {
            "source":model,
            "target":model
        }; 
         Mongo.updateOne("CCO_Delta", { "_id":  v.r_object_id }, {"$set" : transformedDoc }, {"upsert" : true}, targetDB) ; 
        
           mapACLDoc(v);
         createBinary(v);
            }            
    }
    }


transformAll();

function transformAll() {
     foreach(i, doc in allDocsNoVersion()) {
        transformRecordOrContainer(doc);
        mapACL(doc);
        }
    }


//-------------------------------------------------------------------------
//						  FUNCTIONS AND QUERY
//-------------------------------------------------------------------------


function allDocsVersions(){
   var pipeline = [
  {
    "$match": {
      "modified.versions": {
        "$exists": true,
        "$ne": [],
        "$ne": null
      }
    }
  }
]; 
  return Mongo.aggregate("CCO_Delta", pipeline);
}


// 09021748818105929999
// function allDocsNoVersion(){
//     var pipeline = [
//   {
//     "$match": {
//       "$or": [
//         {
//           "original.versions": {
//             "$size": 1
//           }
//         },
//         {
//           "kind": "Folder"
//         }
//       ]
//     }
//   }
// ];
//  return Mongo.find("CCO_Delta", {"_id":"09021748818105929999"});
// }


function allDocsNoVersion(){
    var query = {"kind":"Folder"};
    return Mongo.find("CCO_Delta", query);
    
}



// Transform Record or Container

function transformRecordOrContainer(doc){
    var transformedDoc = {}; 
    var model = {};
    do{
      transformedDoc['_id'] = doc._id; 
        model += mapRequiredProperties(doc); 
        if(doc.kind  == "Document"){
            transformedDoc += {"kind": "RECORD"};
            model += mapDocument(doc);
        
        }
        if(doc.kind == "Folder"){
            transformedDoc += {"kind": "CONTAINER"};
            model += mapFolder(doc);
        }
        transformedDoc += {
            "source":model,
            "target":model
        }; 
    }fail(error){
        // docExtractSuccess = false; 
        // logs[] = {"datetime" : Date.now(), "message" : error, "type" : "error"}; 
    } success {
        // docExtractSuccess = true; 
        // logs[] = {"datetime" : Date.now(), "message" : "Successfully transformed item from content store to UDM.", "type" : "info"}; 
    }finally {
        // Mongo.updateOne('documents', {"_id" : doc._id}, {"$set" : transformedDoc, "$push" : {"migration.logs" : {"$each" : logs}} }, {"upsert" : true}, targetDB) ; 
        Mongo.updateOne('CCO_Delta', {"_id" : doc._id}, 
            {"$set" : {
                "migration": doc.migration
            } }, {"upsert" : true}, targetDB) ; 
    }
            Mongo.updateOne('CCO_Delta', {"_id" : doc._id}, {"$set" : transformedDoc }, {"upsert" : true}, targetDB) ; 

    return transformedDoc;
}





private function mapVersionsRequiredProperties(v){
        var model = {
                            "id": v.r_object_id, 
                            "parentIds": v.i_folder_id, 
                            // "hierarchies": [v.original.fileSystem.path],
                              "name": {
                              "systemName": v.object_name, 
                            //   "displayName": v.original.name.systemName 
                            },
                            "contentType": {
                              "systemName": v.r_object_type
                            //   "displayName": v.original.contentType.systemName 
                            },
                            "states": [],
                            "created": {
                              "date": v.r_creation_date,
                              "principal": {
                                "systemName": v.owner_name, 
                                // "displayName": v.original.created.by 
                              }
                            },
                        };
                        
    return model ; 
}


// map common for Containers and Records
private function mapRequiredProperties(doc){
    var commonPropsModel = {
                            "id": doc.id, 
                            "parentIds": [doc.original.parent.id], 
                            "hierarchies": [doc.original.fileSystem.path],
                              "name": {
                              "systemName": doc.original.name.systemName, 
                            //   "displayName": doc.original.name.systemName 
                            },
                            "contentType": {
                              "systemName": doc.original.contentType.systemName, 
                            //   "displayName": doc.original.contentType.systemName 
                            },
                            "states": [],
                            "created": {
                              "date": doc.original.created.date,
                              "principal": {
                                "systemName": doc.original.created.by.systemName, 
                                // "displayName": doc.original.created.by 
                              }
                            },
                            "lastModified": {
                              "date": doc.original.modified.date,
                              "principal": {
                                "systemName": doc.original.modified.by.systemName,
                                // "displayName": doc.original.modified.by 
                              }
                            },
                             "acls": [],
                            "properties": doc.original.properties,
                        };
                        
    return commonPropsModel ; 
}


// map optionals for Containers and records

private function mapObjectOptional(doc){
    var model = {};  
    if(doc.original.parent.ancestors){
                model += {"ancestors":doc.original.parent.ancestors};
            }
    if(doc.original.description){
                model += {"description": doc.original.description};
            }
                // "lastAccessed": {
    //   // OPTIONAL | OBJECT
    //   "date": "{{source.lastAccessed.date}}", // OPTIONAL | DATE
    //   "principal": {
    //     // OPTIONAL | OBJECT
    //     "systemName": "{{source.lastAccessed.principal.systemName}}", // REQUIRED | STRING
    //     "displayName": "{{source.lastAccessed.principal.displayName}}" // OPTIONAL | STRING
    //   }
    // },
    // "author": {
    //   // OPTIONAL | OBJECT
    //   "principal": {
    //     // REQUIRED | OBJECT
    //     "systemName": "{{source.author.principal.systemName}}", // REQUIRED | STRING
    //     "displayName": "{{source.author.principal.displayName}}" // OPTIONAL | STRING
    //   }
    // },
    // "owner": {
    //   // OPTIONAL | OBJECT
    //   "principal": {
    //     // REQUIRED | OBJECT
    //     "systemName": "{{source.owner.principal.systemName}}", // REQUIRED | STRING
    //     "displayName": "{{source.owner.principal.displayName}}" // OPTIONAL | STRING
    //   }
    // },
    // "language": {
    //   // OPTIONAL | OBJECT
    //   "systemName": "{{source.language.systemName}}", // REQUIRED | STRING
    //   "displayName": "{{source.language.displayName}}", //OPTIONAL | STRING
    //   "masterReference": "{{_id}}" // REQUIRED | STRING | If the object is the master, reference to itself
    // },
    // "web": {
    //   // OPTIONAL | OBJECT
    //   "publishedTo": "{{source.web.publishedTo}}", // OPTIONAL | ARRAY | List of environments where the content is published to
    //   "url": "{{source.web.url}}" // REQUIRED | STRING | Full web URL to the object
    // },
    // "properties": {
    //   // OPTIONAL | OBJECT | Object containing a copy of the original object. Within target it contains the system specific or custom properties.
    // },
    
    // "acls": [
    //   // OPTIONAL | ARRAY OF _ID REFERRING TO THE ACL OBJECTS
    // ],
    // "auditLogs": [
    //  // OPTIONAL | ARRAY OF _ID REFERRING TO THE AUDIT LOG OBJECTS
    // ]
return model;
}

 
//  Map Document
private function mapDocument(doc){
          var model = {};
          model += mapObjectOptional(doc);
          model +={ 
             "hierarchies": [doc.original.fileSystem.path],
             "acls": [],
              "binaries":[ "BIN"::doc._id],
              "versionInfo": {
                              "label":  null, 
                              "minor": 1, 
                              "major": 1, 
                              "seriesId": doc._id, 
                              "isCurrent": null,
                            },
            "lastModified": {
              "date": "",
              "principal": {
                "systemName": doc.original.modified.by.systemName,
                // "displayName": doc.original.modified.by 
              }
            },
            "properties": doc.original.properties,
            };
              return model;
      
}


// Create binary Object
private function createBinary(doc){
        var model = {};
        // var versions = doc.modified.versions;
        // foreach (version in versions){
          model +={ 
                "source": {
                        "source.extension" : doc.dos_extension,
                        "source.rawExtension": doc.dos_extension,
                        "source.byteSize": doc.full_content_size,
                        "source.externalReference": doc.r_object_id,
                        "source.localReference": doc.filevalue,
                        },
                        "properties": doc.version,
                 };
             System.print(doc.r_object_id);
  var result =  Mongo.updateOne("CCO_Delta", {"_id" :"BIN"::doc.r_object_id}, 
            {"$set" : model},{"upsert" : true}, targetDB);
            0;
        //   }
}

// Map folder 
private function mapFolder(doc){
            var model = {}; 
            model += mapObjectOptional(doc) ; 
            model += {
                     "versionInfo": {
                                  "label": "1.0", 
                                  "minor": 1, 
                                  "major": 1, 
                                  "seriesId": doc._id, 
                                  "isCurrent": true,
                                },
                };
        return model;
}


private function mapACL(doc){
if(doc.original.permissions){
var permissions = doc.original.permissions;
foreach(permission in permissions){
    var aclModel = {
 
    "kind":"ACL",
    "source" : {
        "name" : {
            "systemName" : permission.object_name,
            "displayName" : permission.object_name
        },
        "description" : null,
        "created" : {
            "date" : "11/04/2023",
            "principal" : {
                "systemName" : "",
                "displayName" : ""
            }
        },
        "lastModified" : {
            "date" : "12/04/2023",
            "principal" : {
                "systemName" : "",
                "displayName" : ""
            }
        },
        "permissions" : [permission.r_accessor_permit,permission.r_accessor_xpermit ],
        "principals" : permission.r_accessor_name,
        "properties" : {}
    },
    "migration" : {
        "id" : "1",
        "migrate" : true,
        "failed" : false,
        "failedMessage" : "",
        "workerId" : "",
        "workerStatus" : "",
        "retryMessage" : {},
        "retryTarget" : "",
        "origin" : "Test"
    }
};

    var id= Hash.toMD5(doc._id :: permission);
    var result =  Mongo.findOneAndUpdate("CCO_Delta", {"_id": id},{"$set" : aclModel},{"upsert" : true}, targetDB);
    var updateAcl = Mongo.findOneAndUpdate("CCO_Delta", {"_id": doc._id}, {"$push":{"source.acls":id}},{}, targetDB);
           0;

 
}
}
}
    
private function mapACLDoc(doc){
if(Collection.contains(doc.r_version_label,  "CURRENT")){
var getCurrent = Mongo.findOne("CCO_Delta", {"_id":doc.r_object_id}, {}, {},{} ,sourceDB);
var permissions = getCurrent.original.permissions;
foreach(permission in permissions){
    var aclModel = {
 
    "kind":"ACL",
    "source" : {
        "name" : {
            "systemName" : permission.object_name,
            "displayName" : permission.object_name
        },
        "description" : null,
        "created" : {
            "date" : null,
            "principal" : {
                "systemName" : null,
                "displayName" : null
            }
        },
        "lastModified" : {
            "date" : null,
            "principal" : {
                "systemName" : null,
                "displayName" : null
            }
        },
        "permissions" : [permission.r_accessor_permit, permission.r_accessor_xpermit],
        "principals" : permission.r_accessor_name,
        "properties" : {}
    },
    "migration" : {
        "id" : "1",
        "migrate" : true,
        "failed" : false,
        "failedMessage" : null,
        "workerId" : "",
        "workerStatus" : null,
        "retryMessage" : {},
        "retryTarget" : null,
        "origin" : "Test"
    }
};

    var id= Hash.toMD5(doc :: Date.now ());
    var result =  Mongo.findOneAndUpdate("CCO_Delta", {"_id": id},{"$set" : aclModel},{"upsert" : true}, targetDB);
    var updateAcl = Mongo.findOneAndUpdate("CCO_Delta", {"_id": getCurrent._id}, {"$push":{"source.acls":id}},{}, targetDB);
        0;
    }
}
if(!Collection.contains(doc.r_version_label,  "CURRENT")){
    var aclModel = {
 
    "kind":"ACL",
    "source" : {
        "name" : {
            "systemName" : doc.acl_name,
            "displayName" : doc.acl_name
        },
        "description" : null,
        "created" : {
            "date" : null,
            "principal" : {
                "systemName" : null,
                "displayName" : null
            }
        },
        "lastModified" : {
            "date" : null,
            "principal" : {
                "systemName" :null,
                "displayName" : null
            }
        },
        "permissions" : [doc.group_permit,  doc.world_permit],
        "principals" : [doc.acl_domain],
        "properties" : {}
    },
    "migration" : {
        "id" : "1",
        "migrate" : true,
        "failed" : false,
        "failedMessage" : null,
        "workerId" : null,
        "workerStatus" : null,
        "retryMessage" : {},
        "retryTarget" : null,
        "origin" : "Test"
    }
};
    var id= Hash.toMD5(doc::doc.object_name);
    var result =  Mongo.findOneAndUpdate("CCO_Delta", {"_id": id},{"$set" : aclModel},{"upsert" : true}, targetDB);
    var updateAcl = Mongo.findOneAndUpdate("CCO_Delta", {"_id": doc.r_object_id}, {"$push":{"source.acls":id}},{}, targetDB);
          0;
 }
}
   


