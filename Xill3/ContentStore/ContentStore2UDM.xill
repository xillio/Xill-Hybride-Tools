use Assert, Collection, ContentType, Date, Decode, Document, Encode, Excel, ExifTool, File, Hash, MariaDB, Math, Mongo, MSSQL, MySQL, Oracle, Properties, SQLite, Stream, String, System, Template, Web, XML, XURL, Postgres;


// var collectionName = Properties.get("udm.collection");
// var host = Properties.get("udm.host");
// var port = Properties.get("udm.port");
var targetDBName = "2udm";
var targetDB = Mongo.connect(targetDBName);
// var sourceDBName = "xill4_something";
// var sourceDB = Mongo.connect(targetDBName,host,port);
// var nct = {"noCursorTimeout":1,"batchSize":100};

var sourceDB  = Mongo.connect("demoHami");

// create Function that will retrieve BINARY info of given RECORD 


function getBinaryInfo(_id) {   
    var query = {"_id":"BIN"::_id};
    var projection = {
        "source.extension" : 1,
        "source.rawExtension": 1,
        "source.byteSize":1,
        "source.externalReference":1,
        "source.localReference":1
    };
    var binary = Mongo.find("documents", query, projection);
    // binary = collect(binary);
    foreach(i,bin in binary){
    return bin;
    }
}


var pipeline = [
    {"$match" : {"kind" : {"$in" : ["RECORD", "CONTAINER"] }}},
    {"$group": {
        "_id" : "$source.versionInfo.seriesId",
        "docs" : {"$push" : "$$ROOT"},
        "count": {"$sum" : 1}
    }},
    {"$sort" : {"source.versionInfo.label" : 1} }
] ; 


var docsGroupsByVersion = Mongo.aggregate("documents", pipeline, {}, sourceDB) ; 

transformAll();

function transformAll() {
    foreach(i, grouping in docsGroupsByVersion) {
    var documents = grouping.docs; 
    var lenTest = Collection.length(documents) ;
    if(lenTest >1) {
        null ; 
    }
    var currentDocument = documents[Collection.length(documents) -1] ; 
     transformRecordOrContainer(currentDocument, documents);

    }
}



function transformRecordOrContainer(doc,versionDocs){
    var model = {};
    model += mapRequiredProperties(doc,versionDocs); 
    
    if(doc.kind  == "RECORD"){
        model += mapObjectOptional(doc) ; 
        var binary = getBinaryInfo(doc._id);
        
        model +={ 
        "file":{
                    "extension":binary.source.extension, // plug in ibinary info
                    "rawExtension":binary.source.rawExtension, // info binary
                    "size":binary.source.byteSize // binary info
                },
                "mimeType":{
                    "type":doc.source.properties.succinctProperties["cmis:contentStreamMimeType"]
                },
                "versions": mapVersions(versionDocs),
                "properties": doc.source.properties
            };
            

         var update = {"$set": {"_id": doc._id, 
                                "kind": "Document",
                                "original": model,
                                "modified": model
                      }};
    
    
    Mongo.findOneAndUpdate("documents", {"_id":doc._id}, update, {"upsert":true}, targetDB);
    }
    
    if(doc.kind  == "CONTAINER"){
        model += mapObjectOptional(doc) ; 
        model += {
                 "container":{
                     "hasChildren": null,
                 },
                 "properties": doc.source.properties

            };
         var update = {"$set": {"_id": doc._id, 
                                "kind": "Folder",
                                "original": model,
                                "modified": model
                      }};
    
    
    Mongo.findOneAndUpdate("documents", {"_id":doc._id}, update, {"upsert":true}, targetDB);
    }
      
}

private function mapRequiredProperties(doc,versionDocs){
    // map common for folders and records
    var commonPropsModel = {
                 "name" :{
                    "systemName" : doc.source.name.systemName,
                    "displayName" : doc.source.name.systemName,
                    "normalized" : String.toLower(doc.source.name.systemName)
                },
                "parent" : {
                    "id": doc.source.parentIds,
                    "path":doc.source.hierarchies[0],
                    "ancestors":doc.source.parentIds
                },
                "contentType":{
                    "systemName":doc.source.contentType.systemName,
                    "displayName":doc.source.contentType.systemName
                },
                 "created" : {
                    "date" : doc.source.created.date,
                    "by" : doc.source.created.principal.systemName,
                },
                 "modified" : {
                    "date" : doc.source.lastModified.date,
                    "by" : doc.source.lastModified.principal.systemName
                },
                "migration" : {
                    "migrate" : doc.migration.migrate,
                    "origin" : doc.migration.origin,
                },
                  "fileSystem":{
                     "id" : doc.source.id,
                    "path" : doc.source.hierarchies[0],
                    "depth" : ""
                },
                 "permissions" : [],
            };
        
        return commonPropsModel ; 
    
}
private function mapObjectOptional(doc){
    var model = {};
        if(doc.source.properties.succinctProperties["cmis:description"]){
                model += {"description":{"description":doc.source.properties.succinctProperties["cmis:description"]}};
            }
            if(doc.source.ancestors){
                model += {"ancestors":{"ancestors":doc.source.ancestors}};
            }
            if(doc.source.states){
                model += {"states":[doc.source.states]};}
            if(doc.source.lastAccessed){
                model += {"lastAccessed": {"date": doc.source.lastAccessed.date}, 
                            "principal": {
                                "systemName": doc.source.lastAccessed.principal.systemName, 
                                "displayName": doc.source.lastAccessed.principal.displayName
                            }};
            }
            if(doc.source.author){
                model += {"author":{"systemName": doc.source.author.principal.systemName,
                                     "displayName": doc.source.author.principal.displayName}};
            }
            if(doc.source.owner){
                model += {"owner": {"systemName": doc.source.owner.principal.systemName,
                                       "displayName": doc.source.owner.principal.displayName}};
            }
            if(doc.source.language){
                model += {"language": {"systemName": doc.source.language.systemName,
                          "displayName": doc.source.language.displayName,
                          "masterReference": doc._id // REQUIRED | STRING | If the object is the master, reference to itself
                          }};
            }
            if(doc.source.web){
                model += {  "web": {"publishedTo": doc.source.web.publishedTo,
                                     "url": doc.source.web.url // REQUIRED | STRING | Full web URL to the object
                                     }};
            }
            if(doc.source.acls){
                model += { "acls": [doc.source.acls] };
            }
            if(doc.source.auditLogs){
                model += {"auditLogs": [doc.source.auditLogs] };
            }
            
                    return model ;
}


private function mapVersions(versionDocs){
    var versionArr = [] ; 
    foreach(i, version in versionDocs){
        var simpleVersionModel = version.source.properties; 
        versionArr[] = simpleVersionModel ; 
        // plug in binariesadd proeprty "filevalue" : {path to binary}
 
    }
    return versionArr ; 
}





