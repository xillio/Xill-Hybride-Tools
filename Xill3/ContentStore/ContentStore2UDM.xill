use Assert, Collection, ContentType, Date, Decode, Document, Encode, Excel, ExifTool, File, Hash, MariaDB, Math, Mongo, MSSQL, MySQL, Oracle, Properties, SQLite, Stream, String, System, Template, Web, XML, XURL, Postgres;


var targetDBName = "2udm";
var targetDB = Mongo.connect(targetDBName);
var sourceDB  = Mongo.connect("demoHami");

// Function that will retrieve BINARY info of given RECORD 
function getBinaryInfo(_id) {   
    var query = {"_id":"BIN"::_id};
    var projection = {
        "source.extension" : 1,
        "source.rawExtension": 1,
        "source.byteSize":1,
        "source.externalReference":1,
        "source.localReference":1
    };
    var binary = Mongo.find("documents", query, projection);
    foreach(i,bin in binary){
    return bin;
    }
}


function getBinary(_id) {   
    var allBinaries = [];
    var query = {"_id":_id};
    var projection = {
        "source.binaries" : 1,
    };
    var binaries = Mongo.find("documents", query, projection);
    foreach(i,binary in binaries){
      foreach(i,binary in binary.source.binaries){
         var query = {"_id":binary};
         var projection = {
             "source.externalReference" : 1,
          };
         var binaryOne = Mongo.find("documents", query, projection);
             foreach(i,binary in binaryOne){
             allBinaries[] = binary.source.externalReference;
            //  Change externalReference to localReference
          }
        }
     }
return allBinaries;
}

// Function that will retrieve all Versions of given RECORD 

var pipeline = [
    {"$match" : {"kind" : {"$in" : ["RECORD", "CONTAINER"] }}},
    {"$group": {
        "_id" : "$source.versionInfo.seriesId",
        "docs" : {"$push" : "$$ROOT"},
        "count": {"$sum" : 1}
    }},
    {"$sort" : {"source.versionInfo.label" : 1} }
] ; 

var docsGroupsByVersion = Mongo.aggregate("documents", pipeline, {}, sourceDB) ; 
transformAll();

function transformAll() {
    foreach(i, grouping in docsGroupsByVersion) {
    var documents = grouping.docs; 
    var lenTest = Collection.length(documents) ;
    if(lenTest >1) {
        null ; 
    }
    var currentDocument = documents[Collection.length(documents) -1] ; 
     transformRecordOrContainer(currentDocument, documents);
    }
}

function transformRecordOrContainer(doc,versionDocs){
    var model = {};
    model += mapRequiredProperties(doc,versionDocs); 
    
    if(doc.kind  == "RECORD"){
        model += mapObjectOptional(doc) ; 
        var binary = getBinaryInfo(doc._id); // make sure it≈õ an array
        
        model +={ 
        "file":{
                    "extension":binary.source.extension, // plug in ibinary info
                    "rawExtension":binary.source.rawExtension, // info binary
                    "size":binary.source.byteSize // binary info
                },
                "mimeType":{
                    "type":doc.source.properties.succinctProperties["cmis:contentStreamMimeType"]
                },
                "versions": mapVersions(versionDocs),
                "properties": doc.source.properties
            };
         var update = {"$set": {"_id": doc._id, 
                                "kind": "Document",
                                "original": model,
                                "modified": model
                      }};
    Mongo.findOneAndUpdate("documents", {"_id":doc._id}, update, {"upsert":true}, targetDB);
    }
    
    if(doc.kind  == "CONTAINER"){
        model += mapObjectOptional(doc) ; 
        model += {
                 "container":{
                     "hasChildren": null,
                 },
                 "properties": doc.source.properties
            };
         var update = {"$set": {"_id": doc._id, 
                                "kind": "Folder",
                                "original": model,
                                "modified": model
                      }};
    Mongo.findOneAndUpdate("documents", {"_id":doc._id}, update, {"upsert":true}, targetDB);
    }
}

private function mapRequiredProperties(doc,versionDocs){
    // map common for folders and records
    var commonPropsModel = {
                 "name" :{
                    "systemName" : doc.source.name.systemName,
                    "displayName" : doc.source.name.systemName,
                    "normalized" : String.toLower(doc.source.name.systemName)
                },
                "parent" : {
                    "id": doc.source.parentIds,
                    "path":doc.source.hierarchies[0],
                    "ancestors":doc.source.parentIds
                },
                "contentType":{
                    "systemName":doc.source.contentType.systemName,
                    "displayName":doc.source.contentType.systemName
                },
                 "created" : {
                    "date" : doc.source.created.date,
                    "by" : doc.source.created.principal.systemName,
                },
                 "modified" : {
                    "date" : doc.source.lastModified.date,
                    "by" : doc.source.lastModified.principal.systemName
                },
                "migration" : {
                    "migrate" : doc.migration.migrate,
                    "origin" : doc.migration.origin,
                },
                  "fileSystem":{
                     "id" : doc.source.id,
                    "path" : doc.source.hierarchies[0],
                    "depth" : ""
                },
                 "permissions" : [],
            };
    return commonPropsModel ; 
}

private function mapObjectOptional(doc){
    var model = {};
        if(doc.source.properties.succinctProperties["cmis:description"]){
                model += {"description":{"description":doc.source.properties.succinctProperties["cmis:description"]}};
            }
            if(doc.source.ancestors){
                model += {"ancestors":{"ancestors":doc.source.ancestors}};
            }
            if(doc.source.states){
                model += {"states":[doc.source.states]};}
            if(doc.source.lastAccessed){
                model += {"lastAccessed": {"date": doc.source.lastAccessed.date}, 
                            "principal": {
                                "systemName": doc.source.lastAccessed.principal.systemName, 
                                "displayName": doc.source.lastAccessed.principal.displayName
                            }};
            }
            if(doc.source.author){
                model += {"author":{"systemName": doc.source.author.principal.systemName,
                                     "displayName": doc.source.author.principal.displayName}};
            }
            if(doc.source.owner){
                model += {"owner": {"systemName": doc.source.owner.principal.systemName,
                                       "displayName": doc.source.owner.principal.displayName}};
            }
            if(doc.source.language){
                model += {"language": {"systemName": doc.source.language.systemName,
                          "displayName": doc.source.language.displayName,
                          "masterReference": doc._id // REQUIRED | STRING | If the object is the master, reference to itself
                          }};
            }
            if(doc.source.web){
                model += {  "web": {"publishedTo": doc.source.web.publishedTo,
                                     "url": doc.source.web.url // REQUIRED | STRING | Full web URL to the object
                                     }};
            }
            if(doc.source.acls){
                model += { "acls": [doc.source.acls] };
            }
            if(doc.source.auditLogs){
                model += {"auditLogs": [doc.source.auditLogs] };
            }
    return model ;
}


private function mapVersions(versionDocs){
    var versionArr = [] ; 
    foreach(i, version in versionDocs){
        versionArr[] = mapVersion(version) ; 
        null ; 
    }
    return versionArr ; 
}


private function mapVersion(version){
    var versionModel = {}  ; 
    var binaryPath = [] ; 
    do{
        versionModel += version.source.properties;
        var allBinaries = getBinary(version._id); 
        foreach(i,binary in allBinaries){
            binaryPath[] = binary;
        }
    }fail(error){
        System.print("An error was encountered: " :: error, "ERROR") ; 
        
    }success{
        versionModel += {"binaryPath" : binaryPath} ; 
        System.print("Successfully added binary path to version model for id " :: version._id, "DEBUG") ; 
    }
    return versionModel ; 
}


