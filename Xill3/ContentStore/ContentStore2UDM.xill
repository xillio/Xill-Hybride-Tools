use Assert, Collection, ContentType, Date, Decode, Document, Encode, Excel, ExifTool, File, Hash, MariaDB, Math, Mongo, MSSQL, MySQL, Oracle, Properties, SQLite, Stream, String, System, Template, Web, XML, XURL, Postgres;

//-------------------------------------------------------------------------
//						  SETUP
//-------------------------------------------------------------------------

var targetDBName = "2udm";
var targetDB = Mongo.connect(targetDBName);
var sourceDB  = Mongo.connect("demoHami");

//-------------------------------------------------------------------------
//						  MAIN
//-------------------------------------------------------------------------

transformAll();

function transformAll() {
    foreach(i, grouping in groupDocByVersion()) {
        var documents = grouping.docs; 
        var lenTest = Collection.length(documents) ;
        if(lenTest >1) {
            null ; 
        }
        var currentDocument = documents[Collection.length(documents) -1] ; 
        transformRecordOrContainer(currentDocument, documents);
    }
}

//-------------------------------------------------------------------------
//						  FUNCTIONS AND QUERY
//-------------------------------------------------------------------------

//Function that will retrieve ACLS

function getAcls(_id){
    var aclsResp = [];
    var query = {"_id":_id};
    var projection = {
        "source.acls" : 1,
    };
    var resp = Mongo.findOne("documents", query, projection);
    if(resp){
    foreach(res in resp.source.acls)
    {
        var query = {"_id":res};
        var response = Mongo.findOne("documents", query);
        var aclsResponse = response.source;
        aclsResp[] = aclsResponse;
    }
    }
    0;
    return aclsResp;
}

//Function that will retrieve BINARY info of given RECORD

function getBinaryInfo(_id) {   
    var query = {"_id":"BIN"::_id};
    var projection = {
        "source.extension" : 1,
        "source.rawExtension": 1,
        "source.byteSize":1,
        "source.externalReference":1,
        "source.localReference":1
    };
    var binary = Mongo.findOne("documents", query, projection);
    return binary ; 
}

// //Function that will retrieve all versions
function groupDocByVersion(){
    var pipeline = [
    {"$match" : {"kind" : {"$in" : ["RECORD", "CONTAINER"] }}},
    {"$group": {
        "_id" : "$source.versionInfo.seriesId",
        "docs" : {"$push" : "$$ROOT"},
        "count": {"$sum" : 1}
    }},
    {"$sort" : {"source.versionInfo.label" : 1} }
] ; 
return  Mongo.aggregate("documents", pipeline, {}, sourceDB) ;
}




// Transform Document and Folder

function transformRecordOrContainer(doc,versionDocs){
    var logs = []; 
    var transform = mapMigTransformDecorator();
    var load = mapMigLoadDecorator();
    var docExtractSuccess = false; 
    var transformedDoc = {}; 
    var model = {};
    do{
       transformedDoc['_id'] = doc._id; 
        model += mapRequiredProperties(doc,versionDocs); 
        if(doc.kind  == "RECORD"){
            transformedDoc += {"kind": "Document"};
            model += mapDocument(doc, versionDocs);
        }
        if(doc.kind  == "CONTAINER"){
            transformedDoc += {"kind": "Folder"};
            model += mapFolder(doc, versionDocs);
        }
        transformedDoc += {
            "original": model,
            "modified": model
        }; 
    }fail(error){
        docExtractSuccess = false; 
        logs[] = {"datetime" : Date.now(), "message" : error, "type" : "error"}; 
    } success {
        docExtractSuccess = true; 
        logs[] = {"datetime" : Date.now(), "message" : "Successfully transformed item from content store to UDM.", "type" : "info"}; 
    }finally {
        Mongo.updateOne('documents', {"_id" : doc._id}, {"$set" : transformedDoc, "$push" : {"migration.logs" : {"$each" : logs}} }, {"upsert" : true}, targetDB) ; 
        Mongo.updateOne('documents', {"_id" : doc._id}, 
            {"$set" : {
                "migration.export.document" : docExtractSuccess,
                "migration.load" : load,
                "migration.transform" : transform
            } }, {"upsert" : true}, targetDB) ; 
    }
    return transformedDoc;
}

// map common for folders and records

private function mapRequiredProperties(doc,versionDocs){
    var commonPropsModel = {
                 "name" :{
                    "systemName" : doc.source.name.systemName,
                    "displayName" : doc.source.name.systemName,
                    "normalized" : String.toLower(doc.source.name.systemName)
                },
                "parent" : {
                    "id": doc.source.parentIds,
                    "path":doc.source.hierarchies[0],
                    "ancestors":doc.source.parentIds
                },
                "contentType":{
                    "systemName":doc.source.contentType.systemName,
                    "displayName":doc.source.contentType.systemName
                },
                 "created" : {
                    "date" : doc.source.created.date,
                    "by" : doc.source.created.principal.systemName,
                },
                 "modified" : {
                    "date" : doc.source.lastModified.date,
                    "by" : doc.source.lastModified.principal.systemName
                },
                  "fileSystem":{
                     "id" : doc.source.id,
                    "path" : doc.source.hierarchies[0],
                    "depth" : ""
                },
                 "permissions" : mapObjectACL(doc._id),
            };
    return commonPropsModel ; 
}

// map optionals for folders and records

private function mapObjectOptional(doc){
    var model = {};
        if(doc.source.properties.succinctProperties["cmis:description"]){
                model += {"description":{"description":doc.source.properties.succinctProperties["cmis:description"]}};
            }
            if(doc.source.ancestors){
                model += {"ancestors":{"ancestors":doc.source.ancestors}};
            }
            if(doc.source.states){
                model += {"states":[doc.source.states]};}
            if(doc.source.lastAccessed){
                model += {"lastAccessed": {"date": doc.source.lastAccessed.date}, 
                            "principal": {
                                "systemName": doc.source.lastAccessed.principal.systemName, 
                                "displayName": doc.source.lastAccessed.principal.displayName
                            }};
            }
            if(doc.source.author){
                model += {"author":{"systemName": doc.source.author.principal.systemName,
                                     "displayName": doc.source.author.principal.displayName}};
            }
            if(doc.source.owner){
                model += {"owner": {"systemName": doc.source.owner.principal.systemName,
                                       "displayName": doc.source.owner.principal.displayName}};
            }
            if(doc.source.language){
                model += {"language": {"systemName": doc.source.language.systemName,
                          "displayName": doc.source.language.displayName,
                          "masterReference": doc._id // REQUIRED | STRING | If the object is the master, reference to itself
                          }};
            }
            if(doc.source.web){
                model += {  "web": {"publishedTo": doc.source.web.publishedTo,
                                     "url": doc.source.web.url // REQUIRED | STRING | Full web URL to the object
                                     }};
            }
            if(doc.source.acls){
                model += { "acls": [doc.source.acls] };
            }
            if(doc.source.auditLogs){
                model += {"auditLogs": [doc.source.auditLogs] };
            }
    return model ;
}

// Map object ACLS

private function mapObjectACL(_id){
    var acls = getAcls(_id);
    var commonAclModel = [];
    foreach(acl in acls){
        var principals = acl.principals;
        foreach(principal in principals){
             commonAclModel[] = {
                        "principal" : {
                            "principalId" : principal.systemName
                        },
                        "permissions" : acl.permissions
                };
             }
    }
    return commonAclModel;
}

// Transform versions 

private function mapVersions(versionDocs){
    var logs = [];
    var update = {}; 
    var seriesId = versionDocs[0].source.versionInfo.seriesId; 
    do{
        var versionArr = [] ; 
        foreach(i, version in versionDocs){
            versionArr[] = mapVersion(version) ; 
            null ; 
        }
        return versionArr ;    
    }fail(error){
        update['migration.export.versions'] = false ; 
        logs[] = {"datetime" : Date.now(), "message" : error, "type" : "error"}; 
    } success {
        update['migration.export.versions'] = true ; 
        logs[] = {"datetime" : Date.now(), "message" : "Successfully exported the versions from content store to UDM.", "type" : "info"}; 
    }finally {
        Mongo.updateOne('documents', {"_id" : seriesId}, {"$set" : update, "$push" : {"migration.logs" : {"$each" : logs}} }, {"upsert" : true}, targetDB) ; 
    }
}

// Map object for versions

private function mapVersion(version){
    var versionModel = {}  ; 
    var binaryPath = null ; 
    do{
        versionModel += version.source.properties;
        var binary = getBinaryInfo(version._id); 
        binaryPath = binary.source.localReference;
    }fail(error){
        System.print("An error was encountered: " :: error, "ERROR") ; 
    }success{
        versionModel += {"binaryPath" : binaryPath} ; 
        System.print("Successfully added binary path to version model for id " :: version._id, "DEBUG") ; 
    }
    finally{
    }
    return versionModel ; 
}


private function mapDocument(doc, versionDocs){
      var model = {};
      var binary = getBinaryInfo(doc._id); // make sure it≈õ an array
        model +={ 
             "file":{
                    "extension":binary.source.extension, // plug in ibinary info
                    "rawExtension":binary.source.rawExtension, // info binary
                    "size":binary.source.byteSize // binary info
                },
                "mimeType":{
                    "type":doc.source.properties.succinctProperties["cmis:contentStreamMimeType"]
                },
                "versions": mapVersions(versionDocs),
                "properties": [doc.source.properties, mapObjectOptional(doc)]
            };
        return model;
}

private function mapFolder(doc, versionDocs){
    var model = {}; 
     model += mapObjectOptional(doc) ; 
        model += {
                 "container":{
                     "hasChildren": null,
                 },
                 "properties": doc.source.properties
            };
     return model;
}


private function mapMigTransformDecorator(){
    var migDecorator = {
            "createModel" : false
        };
    return migDecorator; 
}

private function mapMigLoadDecorator(){
    var migDecorator = {
            "migrate":false,
            "status":null,
            "target":null,
            "batch": null
    }; 
    return migDecorator; 
}


